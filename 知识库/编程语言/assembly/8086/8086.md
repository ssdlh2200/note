# 8086
## 8086芯片图
![[20251103-17-18-09.png]]

## 8086管理内存(寻址)
### 一块1MB大小的RAM（内存）
| Range  | Size       | Usage     |
| ------ | ---------- | --------- |
| 00000H |            | 主存储器地址空间  |
| 9FFFFH | 640 KB RAM |           |
| A0000H |            | 显存地址空间    |
| BFFFFH | 128 KB RAM |           |
| C0000H |            | 各类ROM地址空间 |
| FFFFFH | 256 KB     |           |

为什么大小刚好是1MB呢？是因为：
- 8086CPU的的地址总线表示内存单元
- 8086CPU有20根地址总线，每根线都有0和1两种表示，20根线能组合的总数位为：
    - $2^{20} = 1,048,576 \text{个内存单元}$
- 每个内存单元1字节，因此最大可寻址能力为：  
    - $2^{20} \text{ Bytes} = 1 \text{ MB}$
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;">
<b>注：现代计算机每个内存单元 = 1 字节（Byte） = 8 位（bits）</b>
</div>

### 解决16位寄存器寻址问题
8086最大的寻址能力是1M，是8086是16位结构的CPU，寄存器处理的最大宽度位16位，此时的寻址能力为：
- $2^{16} \text{ Bytes} = 64 \text{ KB}$
所以8086使用了两个16位的地址段地址，偏移地址使用地址加法器合成了一个20位的物理地址
- $\text{物理地址 = 段地址 × 16 + 偏移地址}$
![[20251103-17-51-07.png]]

### 分段
8086把内存分成段（segment），因为寄存器最大寻址能力为64KB，所以每个段最多64KB


## 8086寄存器

| 寄存器缩写 | 全称                           | 组成部分    | 类型    |
| ----- | ---------------------------- | ------- | ----- |
| AX    | Accumulator Register（累加器寄存器） | AH / AL | 通用寄存器 |
| BX    | Base Register（基址寄存器）         | BH / BL | 通用寄存器 |
| CX    | Count Register（计数寄存器）        | CH / CL | 通用寄存器 |
| DX    | Data Register（数据寄存器）         | DH / DL | 通用寄存器 |
| CS    | Code Segment（代码段寄存器）         | -       | 段寄存器  |
| DS    | Data Segment（数据段寄存器）         | -       | 段寄存器  |
| SS    | Stack Segment（栈段寄存器）         | -       | 段寄存器  |
| ES    | Extra Segment（附加段寄存器）        | -       | 段寄存器  |
| SP    | Stack Pointer（栈指针寄存器）        | -       | 指针寄存器 |
| BP    | Base Pointer（基址指针寄存器）        | -       | 指针寄存器 |
| SI    | Source Index（源变址寄存器）         | -       | 变址寄存器 |
| DI    | Destination Index（目的变址寄存器）   | -       | 变址寄存器 |
| IP    | Instruction Pointer（指令指针寄存器） | -       | 指令指针  |
| FLAGS | Flag Register（标志寄存器）         | -       | 标志寄存器 |

### 通用寄存器
AX寄存器能够存储2个字节的数据，也就是16比特位，能够存储的最大值就是0xFFFF
```text
AX 寄存器 (16位)
┌─────────────────┬─────────────────┐
│       AH        │       AL        │
│ 0 0 0 0 0 0 0 0 │ 0 0 0 0 0 0 0 0 │
└─────────────────┴─────────────────┘

【例】存储18
┌─────────────────┬─────────────────┐
│       AH        │       AL        │
│ 0 0 0 0 0 0 0 0 │ 0 0 0 1 0 0 1 0 │
└─────────────────┴─────────────────┘
```
8086的寄存器是16位的
下一代的32位，64位的寄存兼容上一个代的示意图如下:
```text
EAX 寄存器 (32位)
┌─────────────────┬─────────────────┐
│                 │       AX        │
│      16bits     │      16bits     │
└─────────────────┴─────────────────┘
RAX 寄存器 (64位)
┌─────────────────┬─────────────────┐
│                 │       EAX       │
│      32bits     │      32bits     │
└─────────────────┴─────────────────┘
```
- 8086的 word size（字长）为16bit
- 80386的 word size 为32bit
- x86-64的 word size 为64bit
### 段寄存器
| 段寄存器               | 用途    | 说明                        |
| ------------------ | ----- | ------------------------- |
| CS (Code Segment)  | 代码段   | 存放程序指令，IP 寄存器配合 CS 定位指令地址 |
| DS (Data Segment)  | 数据段   | 存放程序使用的数据，默认大多数数据操作使用 DS  |
| SS (Stack Segment) | 堆栈段   | 存放堆栈数据，SP/BP 寄存器配合 SS 使用  |
| ES (Extra Segment) | 附加数据段 | 辅助存放数据，常用于字符串和数组操作        |

## 8086指令
### mov 数据传送指令
```
MOV 目的操作数, 源操作数
```
把源操作数内容复制到目的操作数

| 类型          | 示例                 | 说明                   |     |
| ----------- | ------------------ | -------------------- | --- |
| 寄存器 ← 寄存器   | MOV AX, BX         | 把 BX 的内容复制到 AX       |     |
| 寄存器 ← 内存    | MOV AL, \[1234H\]  | 把内存单元 1234H 的内容送入 AL |     |
| 内存    ← 寄存器 | MOV \[2000H\], DL  | 把 DL 的内容存入内存 2000H   |     |
| 寄存器 ← 立即数   | MOV CX, 1234H      | 把立即数 1234H 送入 CX     |     |
| 内存    ← 立即数 | MOV \[3000H\], 25H | 把 25H 写入内存 3000H     |     |
- mov只是复制数据，不影响标志寄存器（FLAGS）
- 源数据不会变，只是复制
- ❌不允许内存到内存传送

### add
```asm
assume cs:hello

hello segment

    mov ax, 18h ;将18存入寄存器ax
    mov ah, 78h ;将78存入寄存器ax的高8位
    add al, 0F0h

    mov ax, 4c00h
    int 21h     ;相当于c语言中return 0
hello ends

end
```
- add al bl 若其中al溢出，那么是否会存储到ah中?
- 不会
