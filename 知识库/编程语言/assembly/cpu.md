# cpu
## 8086
### 8086芯片图
![[20251103-17-18-09.png]]

### 8086管理内存(寻址)
#### 一块1MB大小的RAM（内存）
| Range  | Size       | Usage     |
| ------ | ---------- | --------- |
| 00000H |            | 主存储器地址空间  |
| 9FFFFH | 640 KB RAM |           |
| A0000H |            | 显存地址空间    |
| BFFFFH | 128 KB RAM |           |
| C0000H |            | 各类ROM地址空间 |
| FFFFFH | 256 KB     |           |

为什么大小刚好是1MB呢？是因为：
- 8086CPU的的地址总线表示内存单元
- 8086CPU有20根地址总线，每根线都有0和1两种表示，20根线能组合的总数位为：
    - $2^{20} = 1,048,576 \text{个内存单元}$
- 每个内存单元1字节，因此最大可寻址能力为：  
    - $2^{20} \text{ Bytes} = 1 \text{ MB}$
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;color: black">
<b>注：现代计算机每个内存单元 = 1 字节（Byte） = 8 位（bits）</b>
</div>

#### 解决16位寄存器寻址问题
8086最大的寻址能力是1M，是8086是16位结构的CPU，寄存器处理的最大宽度位16位，此时的寻址能力为：
- $2^{16} \text{ Bytes} = 64 \text{ KB}$
所以8086使用了两个16位的地址段地址，偏移地址使用地址加法器合成了一个20位的物理地址
- $\text{物理地址 = 段地址 × 16 + 偏移地址}$
![[20251103-17-51-07.png]]
```
段地址 = 073F
偏移地址 = 0100
真实地址 = 
        073Fh * 10h = 073F0h
        073F0h + 0100h = 074F0h
```


### 8086寄存器

| 寄存器缩写 | 全称                           | 组成部分    | 类型    |
| ----- | ---------------------------- | ------- | ----- |
| AX    | Accumulator Register（累加器寄存器） | AH / AL | 通用寄存器 |
| BX    | Base Register（基址寄存器）         | BH / BL | 通用寄存器 |
| CX    | Count Register（计数寄存器）        | CH / CL | 通用寄存器 |
| DX    | Data Register（数据寄存器）         | DH / DL | 通用寄存器 |
| CS    | Code Segment（代码段寄存器）         | -       | 段寄存器  |
| DS    | Data Segment（数据段寄存器）         | -       | 段寄存器  |
| SS    | Stack Segment（栈段寄存器）         | -       | 段寄存器  |
| ES    | Extra Segment（附加段寄存器）        | -       | 段寄存器  |
| SP    | Stack Pointer（栈指针寄存器）        | -       | 指针寄存器 |
| BP    | Base Pointer（基址指针寄存器）        | -       | 指针寄存器 |
| SI    | Source Index（源变址寄存器）         | -       | 变址寄存器 |
| DI    | Destination Index（目的变址寄存器）   | -       | 变址寄存器 |
| IP    | Instruction Pointer（指令指针寄存器） | -       | 指令指针  |
| FLAGS | Flag Register（标志寄存器）         | -       | 标志寄存器 |


#### 通用寄存器

AX寄存器能够存储2个字节的数据，也就是16比特位，能够存储的最大值就是0xFFFF
```text
AX 寄存器 (16位)
┌─────────────────┬─────────────────┐
│       AH        │       AL        │
│ 0 0 0 0 0 0 0 0 │ 0 0 0 0 0 0 0 0 │
└─────────────────┴─────────────────┘

【例】存储18
┌─────────────────┬─────────────────┐
│       AH        │       AL        │
│ 0 0 0 0 0 0 0 0 │ 0 0 0 1 0 0 1 0 │
└─────────────────┴─────────────────┘
```
8086的寄存器是16位的
下一代的32位，64位的寄存兼容上一个代的示意图如下:
```text
EAX 寄存器 (32位)
┌─────────────────┬─────────────────┐
│                 │       AX        │
│      16bits     │      16bits     │
└─────────────────┴─────────────────┘
RAX 寄存器 (64位)
┌─────────────────┬─────────────────┐
│                 │       EAX       │
│      32bits     │      32bits     │
└─────────────────┴─────────────────┘
```

#### 段寄存器
8086CPU不支持将数据直接送入段寄存器

| 段寄存器               | 用途    | 说明                        |
| ------------------ | ----- | ------------------------- |
| CS (Code Segment)  | 代码段   | 存放程序指令，IP 寄存器配合 CS 定位指令地址 |
| DS (Data Segment)  | 数据段   | 存放程序使用的数据，默认大多数数据操作使用 DS  |
| SS (Stack Segment) | 堆栈段   | 存放堆栈数据，SP/BP 寄存器配合 SS 使用  |
| ES (Extra Segment) | 附加数据段 | 辅助存放数据，常用于字符串和数组操作        |

##### CS、IP寄存器
CPU通过 $CS × 10h + IP = 物理地址$ 访问到真实的物理地址执行指令 
```c
---------------------------- 内存示意图 ----------------------------
地址       | 内容
----------------------------
074F0h    | [指令字节1]  ← CPU 从这里开始取指令
074F1h    | [指令字节2]
074F2h    | [指令字节3]
074F3h    | [指令字节4]  ← 如果指令是4字节
074F4h    | ...
074F5h    | ...
...
-------------------------------------------------------------------
```
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;color: black" >
问：内存中有数据B8 23 01 BB 03 00 89 D8 01 D8究竟用作一般数据，还是用作指令？<br>
答：CPU将CS:IP指向的内存单元中的内容看作指令！
</div>

##### DS寄存器
如果我们要从内存单元中读取数据，必须要先得到内存单元的地址，而内存地址是段地址和偏移地址的组合
```
mov ax, 3000H
mov ds, ax
mov bx, [0];8086CPU一次将传送一个字的数据，也就是2字节
```
$\text{真实的物理地址} = ds × 10H + 0$ ，从这个地址访问内存，将数据赋值给bx
**数据段**
累加数据段前三个单元的数据
![[20251105-23-29-00.png]]
```asm
mov ax, 5000
mov ds, ax
mov ax, 0
add ax, [0]
add ax, [2]
add ax, [4]
```

### 8086栈
8086中栈是一段连续的内存空间（高地址到低地址），由SS（段寄存器）和SP(栈指针共同管理)
- SS：栈顶段寄存器
- SP：栈顶偏移地址
8086中操作栈都是以字为单位操作
$物理地址栈顶​=SS×16+SP$

### 8086字的存储
8086是16位CPU，所以字的比特位是16位，大小就是2字节，那么存储4E20H，在内存中如何存储呢？
低位字节在低地址单元，高位字节在高地址单元，在内存中存储如下：
```
00 00 20 4E 00 00
```
- 8086     word size（字长）为16bit
- 80386   word size 为32bit
- x86-64  word size 为64bit

### MS-DOS
#### Debug
debug是dos下的调试程序，可以查看CPU寄存器、内存的情况

| 命令    | 功能说明                  | 用途                          |
| ----- | --------------------- | --------------------------- |
| **R** | 查看、修改 **CPU寄存器** 的内容  | 查看或手动更改寄存器状态（如AX、BX、CS、IP等） |
| **D** | 查看**内存**中的内容（以十六进制显示） | 检查指定内存地址中的数据或指令             |
| **E** | 修改**内存**中的内容          | 手动编辑内存数据或指令                 |
| **U** | 将内存中的**机器指令反汇编**为汇编指令 | 分析某段机器码对应的汇编代码              |
| **A** | 以**汇编指令格式写入机器指令**到内存  | 在指定内存地址直接编写汇编指令             |
| **T** | **单步执行**一条机器指令        | 调试程序，逐条执行机器指令并观察结果          |
| **Q** | 退出debug模式             |                             |


-  r命令
![[20251105-15-05-04.png]]
- d命令
    - d 段地址:偏移地址 
    - d 段地址:偏移地址 结束地址的偏移地址（省略结束地址默认显示128个字节）
```
-d 73f:100 f ❌
    起始地址：73fh * 10h + 100h = 74f0h
    结束地址：73fh * 10h + fh = 73ff报错 
    
    
-d 73f:100 107 ✔️
    起始地址：73fh * 10h + 100h = 74f0h
    结束地址：73fh * 10h + 107h = 74f7h
```
![[20251105-15-50-00.png]]
- e命令
![[20251105-15-17-55.png]]
- u命令
![[20251105-15-21-34.png]]
- a命令
    - a命令默认也是往CS:IP处写指令
![[20251105-16-04-20.png]]
- t命令
    - 执行CS:IP处的指令
![[20251105-16-06-01.png]]

## 现代CPU
### 寄存器
#### RBP、EBP、BP
Base Pointer（栈基指针），是函数调用和栈帧管理的重要寄存器
**栈帧中RBP的作用**
在函数调用中，通常会建立栈帧（stack frame）
```asm
push rbp     ;保存调用者的基指针
mov rbp, rsp ;建立当前函数的栈基指针
sub rsp, X   ;为局部变量分配空间
```
在函数结束时
```
mov rsp, rbp ;恢复栈顶位置
pop rbp      ;恢复调用者rbp
ret          ;返回 
```

| 指令/操作            | 与 RBP 的关系  |
| ---------------- | ---------- |
| push rbp         | 保存调用者的基指针  |
| mov rbp, rsp     | 建立当前函数栈帧基准 |
| \[rbp - offset\] | 访问局部变量     |
| \[rbp + offset\] | 访问函数参数     |
| pop rbp          | 恢复调用者基指针   |
【例】下面将分析这个简单的c语言程序
```c
#include <stdio.h>  
int add(int a, int b){ return a + b; }  
int sub(int a, int b){ return a - b; } 
int main()  
{  
    int x = 10;  
    int y = 5;  
    int r1 = add(x, y);  
    int r2 = sub(x, y);  
    printf("r1 = %d, r2 = %d", r1, r2);  
}
```
反汇编代码如下：
```
00007FF698E3165A | push rbp                           |
00007FF698E3165B | mov rbp,rsp                        |
00007FF698E3165E | sub rsp,30                         |
00007FF698E31662 | call index.7FF698E31777            | 调用main方法
00007FF698E31667 | mov dword ptr ss:[rbp-4],A         | 0A:'\n'
00007FF698E3166E | mov dword ptr ss:[rbp-8],5         |
00007FF698E31675 | mov edx,dword ptr ss:[rbp-8]       |
00007FF698E31678 | mov eax,dword ptr ss:[rbp-4]       |
00007FF698E3167B | mov ecx,eax                        |
00007FF698E3167D | call index.7FF698E31634            | 调用add方法
00007FF698E31682 | mov dword ptr ss:[rbp-C],eax       |
00007FF698E31685 | mov edx,dword ptr ss:[rbp-8]       |
00007FF698E31688 | mov eax,dword ptr ss:[rbp-4]       |
00007FF698E3168B | mov ecx,eax                        |
00007FF698E3168D | call index.7FF698E31648            | 调用sub方法
00007FF698E31692 | mov dword ptr ss:[rbp-10],eax      |
00007FF698E31695 | mov edx,dword ptr ss:[rbp-10]      |
00007FF698E31698 | mov eax,dword ptr ss:[rbp-C]       |
00007FF698E3169B | mov r8d,edx                        |
00007FF698E3169E | mov edx,eax                        |
00007FF698E316A0 | lea rax,qword ptr ds:[7FF698E3B000 | 00007FF698E3B000:"r1 = %d, r2 = %d"
00007FF698E316A7 | mov rcx,rax                        |
00007FF698E316AA | call index.7FF698E315E0            |
00007FF698E316AF | mov eax,0                          |
00007FF698E316B4 | add rsp,30                         |
00007FF698E316B8 | pop rbp                            |
```

1. 调用add方法前后的的反汇编查看寄存器如下：
```asm
; 调用call前：rbp = 000000F5375FF810
; 调用call前：rsp = 000000F5375FF7E0

call index.7FF698E31634

; 调用call后：rbp = 000000F5375FF810
; 调用call后：rsp = 000000F5375FF7D8

```

#### RSP
栈指针寄存器
保存栈顶元素的内存地址

#### CS、RIP(EIP、IP)

| 寄存器            | 存放内容                       | 说明   |
| -------------- | -------------------------- | ---- |
| IP / EIP / RIP | 下一条指令的偏移/虚拟地址              | 指令指针 |
| CS             | 存储Segment Selector，参与特权级检查 |      |
