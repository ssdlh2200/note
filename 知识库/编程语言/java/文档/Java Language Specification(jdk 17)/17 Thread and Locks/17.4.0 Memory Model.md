# 17.4.0 Memory Model
## 17.4.0. 编译器优化带来的困扰
### 指令重排序
指令（instruction）
下面将按照文档中的例子说明
```text
+-----------+-----------+
| Thread 1  | Thread 2  |
+-----------+-----------+
| 1: r2 = A;| 3: r1 = B;|
| 2: B = 1; | 4: A = 2; |
+-----------+-----------+
```
假定初始状态下，A\=\=B\=\=0，直观下要不指令1先执行，要不指令3先执行，那么结果上r1或者r2必定有一个为0
但是在编译器将语句重排的情况下，就有可能出现如下：
- 2->3->4->1，结果为r1\=\=1，r2\=\=2
❗指令4竟然在指令1的前面执行
这是因为，编译器允许在不改变单线程语义的情况下重排指令，对于thread 1来说，编译器将指令2重排在指令1的前方了
```
+-----------+
| Thread 1  |
+-----------+
| 2: B = 1; |
| 1: r2 = A;|
+-----------+
```
下面这段代码能够跑出指令重排的效果
```java
public class JMMTest2 {  
    static int A = 0, B = 0, r1 = 0, r2 = 0;  
    public static void main(String[] args) throws InterruptedException {  
  
        while (true) {  
            Thread t1 = new Thread(() -> {  
                r2 = A;  
                B = 1;  
            });  
            Thread t2 = new Thread(() -> {  
                r1 = B;  
                A = 2;  
            });  
            t1.start();  
            t2.start();  
            t1.join();  
            t2.join();  
            System.out.println("r1:" + r1 + "  " + "r2:" + r2);  
            if (r1 == 1 && r2 == 2) {  
                System.out.println("指令重排");  
                break;  
            }  
            A = 0;  
            B = 0;  
            r1 = 0;  
            r2 = 0;  
        }  
    }  
}
```

### 向前替代（forward substitution）
如果两次读取的是相同的变量，并且中间没有写操作，那么编译器会复用前一次读取的结果，例如下面所示

| Thread 1     | Thread 2   |
| ------------ | ---------- |
| r1 = p1.age; | p1.age=100 |
| 执行其他代码       |            |
| r2 = p1.age  |            |
我们发现在r1和r2之间线程1内并没有修改p1.age的值，所以编译器可能会做出如下优化

| Thread 1     | Thread 2   |
| ------------ | ---------- |
| r1 = p1.age; | p1.age=100 |
| 执行其他代码       |            |
| r2 = r1      |            |
直接让r2复用了r1的值

```java
public class JMMTest4 {  
  
    static int r1 = 0, r2 = 0;  
  
    public static void main(String[] args) throws InterruptedException {  
        while (true){  
            Person p1 = new Person();  
            p1.age = 10;  
            Thread t1 = new Thread(() -> {  
                r1 = p1.age;  
                try {  
                    Thread.sleep(10);  
                } catch (InterruptedException e) {  
                    throw new RuntimeException(e);  
                }  
                r2 = p1.age;  
            });  
            Thread t2 = new Thread(() -> {  
                try {  
                    Thread.sleep(5); // 让r1 = p1.age先执行  
                } catch (InterruptedException e) {  
                    throw new RuntimeException(e);  
                }  
                p1.age = 100;  
            });  
            t1.start();  
            t2.start();  
            t1.join();  
            t2.join();  
            System.out.printf("r1:%d, r2:%d, p1.age:%d\n", r1, r2, p1.age);  
            if (r1 == r2 && r1 == 10){  
                System.out.println("向前替代");  
                break;  
            }  
            r1 = 0;  
            r2 = 0;  
            p1.age = 10;  
        }  
  
    }  
}  
class Person{  
    int age;  
}
```

## 17.4.5 Happends-before Order
两条操作可以通过 happends-before 关系进行排序。如果一个操作 happends before 另一个操作，那么第一个操作对第二个操作是可见的，并且发生在第二个操作之前
**我们用hb(x,y)表示x happends-before y**
- 一个对象构造器的 start 和 finalizer 存在hb
- 同步操作（lock/unlock 或 volatile）会产生hb
- hb(x,y) 且 hb(y,z)则存在hb(x,z)
- wait()/notify()，隐含的锁操作决定hb
- 两个操作之间存在hb，并不意味着必须严格按照顺序执行，有可能发生指令重排。只要重排不会产生非法结果
- 线程初始化对象默认字段，不一定在该线程开始前完成，只要没有其他线程读取就行
