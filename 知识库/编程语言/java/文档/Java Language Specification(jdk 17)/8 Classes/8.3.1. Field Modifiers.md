# 8.3.1. Field Modifiers
## 8.3.1.3. transient Fields


## 8.3.1.4. volatile Fileds
### 特性

#### JMM保证可见性
Java中除了使用锁保证线程对变量的独占使用，还提供了volatile fileds，相比锁方便使用
一个字段可以被声明为volatile，此时JMM保证所有线程能看到变量的一致性（<font color="#c00000">一致性：当变量被某个线程修改时，其它线程能够立刻看到最新值</font>）
```java
static boolean noVolatileRunning = true;  
static volatile boolean volatileRunning = true;  
  
public static void main(String[] args) throws InterruptedException {  
    new Thread(() -> {  
        System.out.println("t1线程进入循环");  
        while (noVolatileRunning){  
            int x = 0;  
            x++;  
        }  
        System.out.println("t1线程退出循环");  
    }, "t1").start();  
  
    new Thread(() -> {  
        System.out.println("t2线程进入循环");  
        while (volatileRunning){  
            int x = 0;  
            x++;  
        }  
        System.out.println("t2线程退出循环");  
    }, "t2").start();  
  
    Thread.sleep(100);  
    noVolatileRunning = false;  
    volatileRunning = false;  
}
```
运行结果
```text
t1线程进入循环
t2线程进入循环
t2线程退出循环
```
- t1线程无法退出循环的原因是JVM/CPU可能会把noVolatileRunning缓存在寄存器/线程本地，导致t1线程无法看到更新
- t2线程正常退出则是因为volatile保证了
    - 写入变量时立刻刷新到主存
    - 读取变量时一定能看到最新值

#### JMM保证happens-before（禁止指令重排序）
禁止指令重排序
```java

static int data = 0;  
static volatile boolean ready = false;    
public static void main(String[] args) {  
    for (int i = 0; i < 1000000; i++) {//循环次数多保证JIT优化代码为汇编代码  
        data = 42; // 普通写  
        ready = true; //volatile写  
    }
}
```
在编译器和CPU执行层面，JMM会插入内存屏障，确保
- data = 42，刷新到主内存（内存中真正生效）
- 然后才执行ready = true 的写
- 禁止CPU和编译器对这两个指令顺序对调
因此，当另外一个线程看到ready == true时，一定也能看到之前写入的data = 42
- 对于volatile写操作，JMM要求插入 StoreStoreBarrier 和 StoreLoadBarrier
- 对于volatile读操作，JMM要求插入 LoadLoadBarrier 和 LoadStoreBarrier
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;color: black" >hotspot中使用lock指令来达到内存屏障的效果<br>
在一条带有 lock 前缀的指令之前的所有读写操作，必须在这条指令之前完成；而这条指令之后的所有读写操作，必须在这条指令完成之后才能开始。</div>

>一个变量不可能同时被final和volatile修饰，编译器报错

#### volatile无法保证原子性
```java
volatile int count = 0;
count++;
```
这里count++包含读、改、写三个步骤-
- ICONST_0、ISTORE 1、IINC 1 1
多个线程执行仍然可能产生竞态，所以对于简单的读，写使用volatile足够（比如开关，标志位），对于符合操作，仍需要synchronized或者ReentranLock

### volatile实际使用
#### 1. 指令乱序带来的麻烦
- [[17.4.0 Memory Model#指令重排序]]
```java
class Test { 
    static int i = 0, j = 0; 
    static void one() { i++; j++; } 
    static void two() { 
    System.out.println("i=" + i + " j=" + j); 
    } 
}
```
Thread1调用one()方法，Thread2调用two()方法，直观来看，i和j的值应该一直相等
```
+-----------+-----------+
| Thread 1  | Thread 2  |
+-----------+-----------+
| 1: i++    | 3:println |
| 2: j++    |           |
+-----------+-----------+
```
- **CPU切换执行导致i和j值不相等：** 分配时间片给Thread1，刚执行完1号指令i++，时间片耗光，CPU再分配时间片给Thread2执行3号指令打印i和j的值
- **指令重排导致j>i：** 如果2号指令（j++）因为优化重排在1号指令（i++）前执行，且执行完2号指令（j++）后，CPU将时间片分配给Thread2执行3号指令（println）, 会导致j的值大于i的值
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f; color: black">
⚙️上面的效果想用java代码复现？
<br>
<b>1. JIT 编译器非常智能</b>
<br><span>&emsp;&emsp;</span>
JVM 的 JIT 优化通常只在热代码路径（HotSpot）上生效，线程生命周期太短、执行路径太冷，JIT 根本来不及优化和重排
<br>
<b>2. i++ / j++ 是内存访问，不容易跨越重排</b>
<br><span>&emsp;&emsp;</span>
两次自增访问的是不同变量的内存位置（i、j 分别有独立的缓存行），即使重排了，CPU 缓存一致性机制（MESI 协议）也会掩盖掉这种效果。
<br>  
<b>3. 重排发生的概率极低且不可观测</b>
<br><span>&emsp;&emsp;</span>指令重排是微观层面的执行优化，除非使用特定的压力测试工具或 `volatile` 屏障验证，在一般 Java 程序中几乎观测不到。
</div>

#### 2.使用synchronized解决
```java
static int i = 0, j = 0;  
static synchronized void one(){  
    i++;  
    j++;  
}  
static synchronized void two(){  
    System.out.printf("i = %d, j = %d\n", i, j);  
}
```
synchronized能够保证i++和j++同时执行。因为静态方法的锁是Class对象，哪怕当线程执行one()时时间片耗光去执行two()方法，也会因为无法获得锁而进入entrylist等待锁的释放

#### 3. 使用volatile解决

```

```