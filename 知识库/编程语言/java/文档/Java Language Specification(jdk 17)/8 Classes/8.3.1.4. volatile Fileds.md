## 8.3.1.4. volatile Fileds
### 介绍
Java中除了使用锁保证线程对变量的独占使用，还提供了volatile fileds，相比锁方便使用
- 一个字段可以被声明为volatile，此时JMM保证所有线程能看到变量的一致性
<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;">
一致性：当变量被某个线程修改时，其它线程能够立刻看到最新值
</div>
- 一个变量不可能同时被final和volatile修饰，编译器报错
volatile只保证可见性，不保证原子性
```java
volatile int count = 0;
count++;
```
这里count++包含读、改、写三个步骤，多个线程执行仍然可能产生竞态，所以对于简单的读，写使用volatile足够（比如开关，标志位），对于符合操作，仍需要synchronized或者ReentranLock
### volatile实际使用
#### 指令乱序带来的
- [[17.4.0 Memory Model#指令重排序]]

```java
class Test { 
    static int i = 0, j = 0; 
    static void one() { i++; j++; } 
    static void two() { 
    System.out.println("i=" + i + " j=" + j); 
    } 
}
```
一个线程调用one()方法，另外一个线程调用two()方法，直观来看，i和j的值应该一直相等
- cpu切换执行：当one()方法执行到i++;结束后，cpu去执行two()方法的打印，那么会导致i与j的值不相等
- 指令重排：如果j++;指令因为优化重排在i++前执行，且执行完j++指令后就去执行two()方法, 会导致j的值大于i的值
```java
static int i = 0, j = 0;  
static void one() { i++; j++; }  
static void two() {  
    if (i != j) {  
        System.out.printf("⚠️ i=%d, j=%d%n", i, j);  
    }  
    System.out.printf("%d %d\n", i, j);  
}
```
结果为
```text
0 1
1000 1000
1000 1000
1000 1000
1000 1000
```
为什么没有执行if分支里面的内容呢？
- 因为编译器在读取i和j的时候，从内存或者寄存器取一次值
- 在printf的时候在内存或者寄存器取一次值
因为没有同步，这两次读取不保证一致，甚至可能有不同时机，不同的可见性

使用synchronized解决



