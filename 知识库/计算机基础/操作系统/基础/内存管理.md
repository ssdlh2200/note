# 内存管理
## 传统内存管理
**问题1：能够直接访问物理内存**
<span>&emsp;&emsp;</span>传统的内存管理使得CPU能够直接访问物理内存，例如我们在dosbox中修改中断向量表导致系统崩溃
![[20251105-17-31-34.png]]
在传统的内存管理中，一个程序可以任意访问修改另外一个程序的内存
**问题2：连续内存导致内存碎片化**
<span>&emsp;&emsp;</span>在内存分配中，会连续分配一段内存空间给程序
```
Physical Memory Address Space (1MB):
┌────────────────────────────┐ FFFFFh
│ BIOS ROM                   │
├────────────────────────────┤
│ Program 3: CS=3000h (64KB) │
├────────────────────────────┤
│ Program 2: CS=2000h (64KB) │
├────────────────────────────┤
│ Program 1: CS=1000h (64KB) │
├────────────────────────────┤
│ IVT & BIOS Data Area       │ (00000h~004FFh)
└────────────────────────────┘ 00000h
```
若此时程序1，3执行完毕，将program1和program3的内存释放掉
```
┌────────────────────────────┐ FFFFFh
│ BIOS ROM                   │
├────────────────────────────┤
│       free                 │
├────────────────────────────┤
│ Program 2: CS=2000h (64KB) │
├────────────────────────────┤
│       free                 │
├────────────────────────────┤
│ IVT & BIOS Data Area       │ (00000h~004FFh)
└────────────────────────────┘ 00000h
```
空闲空间为128KB，但是因为内存不连续，导致下一个程序内存只要超过64KB就无法允许
**问题3：内存不足**
<span>&emsp;&emsp;</span>直接内存分配导致程序需要全部加载进内存中才能够允许，导致无法运行许多程序

## 现代内存管理
### 虚拟内存(virtual memory)
为了解决传统内存访问的不便，采用了虚拟内存来解决，操作系统创建一个虚拟空间并将其映射到物理内存上，每个进程都有自己的虚拟内存空间
- **操作系统为进程创建虚拟空间**
```
Virtual Memory(虚拟内存)
┌───────────────┐
│     Page 0    │ 
├───────────────┤
│     Page 1    │
├───────────────┤
│     Page 2    │
├───────────────┤
│     Page 3    │
└───────────────┘
```
通常page（页）的大小为4KB
- **物理内存分块**
将物理内存也划分为小块，每块称为frame（页框），大小为4KB刚好存放一个page
```
Physical Memory(物理内存)
┌───────────────┐
│ Frame 4       │
├───────────────┤
│ Frame 5       │
├───────────────┤
│ Frame 6       │
├───────────────┤
│ Frame 7       │
└───────────────┘
```
- **页表建立**
当我们加载程序时，将page按需加载进frame
```
页表示例：
┌───────────────────────────────┐
│ 虚拟页 0 → 物理页框 5         │
│ 虚拟页 1 → 物理页框 6         │
│ 虚拟页 2 → 物理页框 4         │
│ 虚拟页 3   物理页框 7         │
└───────────────────────────────┘
```

<div style="background-color: #ffe4e1; padding: 10px; border-left: 4px solid #f1c40f;color: black" >我们可以将所有程序使用的共享代码，也就是库，加载进物理内存中，这些页称为shared page共享页</div>

### 地址转换-MMU(内存管理单元)
```c
┌──────────────────────────────────────┐
│                 CPU                  │
│ ┌──────────────────────────────────┐ │
│ │ Instruction: MOV AX, [0x00401234]│ ← 程序访问virtual address
│ └──────────────────────────────────┘ │
│                │                     │
│                ▼                     │
│     [Virtual Address: 0x00401234]    │
│                │                     │
│                ▼                     │
│         ┌──────────────┐             │
│         │     MMU      │             ← MMU(Memory Management Unit)(硬件)
│         └──────────────┘             │
│                │                     │
│        Virtual Page + Offset         │
│        Virtual Page = 0x00401        │
│        Page Offset  = 0x234          │
│                │                     │
│                ▼                     │
│            Page Table                │
│  Page(0x00401) → Frame (0x000A)      │
│                │                     │
│                ▼                     │
│   Physical Addr = 0x000A0000 + 0x234 │
│                │                     │
│                ▼                     │
│     [Physical Address: 0x000A0234]   │
└────────────────┬─────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────┐
│          Physical Memory (RAM)       │
│ ┌────────────────────────────────┐   │
│ │ Address 0x000A0234 → Data "H"  │   ← Actual data fetched
│ └────────────────────────────────┘   │
└──────────────────────────────────────┘

```



![[20251105-20-17-56.jpg]]
1.要算出逻辑地址对应的页号
页号=逻辑地址/页面长度（取除法的整数部分）

80 / 50 = **1号页面**

2.要知道该页号对应页面在内存中的起始地址

页面在内存中的起始位置：操作系统需要用某种数据结构记录进程各个页

面的起始位置。

**1号页在内存中存放的起始位置450**

3.要算出逻辑地址在页面内的“偏移量”

页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）

80 % 50 = **30偏移量**

4.物理地址=页面始址+页内偏移量



为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂



假设用32个二进制位表示逻辑地址，页面大小为2^12B=4096B=4KB

0号页的逻辑地址空间应该是0~4095，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">00</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">00</font>****<u>1111,1111,1111</u>**

1号页的逻辑地址空间应该是4096~8191，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">01</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">01</font>****<u>1111,1111,1111</u>**

2号页的逻辑地址空间应该是8192~12287，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">10</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">10</font>****<u>1111,1111,1111</u>**

结论：如果每个页面大小为2B,用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号

:::

#### 逻辑结构地址
以页面大小为2^12B为例

| **31            ......................                    12** | **11            ....              0** |
| --- | --- |
| **页号P** | **页内偏移量W** |


:::info
Eg:逻辑地址2，用二进制表示应该是000000000000000000**<font style="color:#DF2A3F;">00</font>**,0000,0000,0010

可知页号为0

若0号页在内存中的起始地址为X,则逻辑地址2对应的物理地址应该是X+000000000010



Eg:逻辑地址4097，用二进制表示应该是000000000000000000**<font style="color:#DF2A3F;">01</font>**,0000,0000,0001

可知页号为1

若1号页在内存中的起始地址为X,则逻辑地址4097对应的物理地址应该是X+000000000001

:::

#### 页表
为了得知每个页面在内存中的起始地址。

+ 1.一个进程对应一张页表
+ 2.进程的每一页对应一个页表项
+ 3.每个**<font style="color:#DF2A3F;">页表项</font>**由“页号”和“块号”组成
+ 4.页表记录进程页面和实际存放的内存块之间的对应关系
+ 5.M号内存块的起始地址就是M*内存块大小

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/33704534/1676722021838-bf937b70-dcae-499e-9d34-65f6904361b5.jpeg)

#### 为什么每个页表项的长度是相同的，页号是“隐含”的？
Eg：假设某系统物理内存大小为4GB,页面大小为4KB,则每个页表项至少应该为多少字节？

+ 4GB=2^32B	4KB=2^12B
+ 因此4GB的内存总共会被分为2^32/2^12=2^20个内存块，因此内存块号的范围应该是0~2^20-1
+ 因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够

各页表项会按顺序连续地存放在内存中，如果该页表在内存中存放的起始地址为X，则M号页对应的页表项一定是存放在内存地址为X+3*M，然后在该地址找块号是多少。

在本例中，一个页表项占3B,如果进程由n个页面，则该进程的页表总共会占3*n个字节



## 页面置换算法
**回顾**

+ 请求分页存储管理与基本分页存储管理的主要区别：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
+ **<font style="color:#DF2A3F;">用页面置换算法决定应该换出哪个页面</font>**

页面的换入、换出需要磁盘I/0,会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**

### 最佳置换算法OPT
每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：

7，0，1，2，0，3，0，4‘2，3，0，3，2，1，2，0’1，7，0，1

| **访问页面** | **7** | **0** | **1** | **2** | **0** | **3** | **0** | **4** | **2** | **3** | **0** | **3** | **2** | **1** | **2** | **0** | **1** | **7** | **0** | **1** |
| --- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **内存块1** | <font style="color:#DF2A3F;">7</font> | 7 | 7 | **<font style="color:#2F8EF4;">2（标注1）</font>** |  | 2 | <font style="color:#DF2A3F;"></font> | 2 |  |  | 2 |  |  | 2 |  |  |  | <font style="color:#DF2A3F;">7</font> |  |  |
| **内存块2** |  | <font style="color:#DF2A3F;">0</font> | 0 | 0 |  | 0 |  | <font style="color:#DF2A3F;">4</font> |  |  | <font style="color:#DF2A3F;">0</font> |  |  | 0 |  |  |  | 0 |  |  |
| **内存块3** |  |  | <font style="color:#DF2A3F;">1</font> | 1 | <font style="color:#DF2A3F;"></font> | <font style="color:#DF2A3F;">3</font> |  | 3 |  |  | 3 |  |  | <font style="color:#DF2A3F;">1</font> |  |  |  | 1 |  |  |
| **是否缺页** | 是 | 是 | 是 | 是 |  | 是 |  | 是 |  |  | 是 |  |  | 是 |  |  |  | 是 |  |  |


**<font style="color:#2F8EF4;">2（标注1）：选择从0,1,7中淘汰一页。按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面</font>**

+ 整个过程**缺页中断发生了9**次，**页面置换发生了6**次。

注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。

+ **缺页率 = 9 / 20 = 45%**

### 评价
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

### 先进先出置换算法FIFO
每次选择淘汰的页面是最早进入内存的页****面

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。

队列的最大长度取决于系统为进程分配了多少个内存块。

例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：

3，2，1，0，3，2，4，3‘2，1，0，4

| **访问页面** | **3** | **2** | **1** | **0** | **3** | **2** | **4** | **3** | **2** | **1** | **0** | **4****** |
| --- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **内存块1** | <font style="color:#DF2A3F;">3</font> | 3 | 3 | <font style="color:#DF2A3F;">0</font> | 0<font style="color:#DF2A3F;"></font> | 0 | <font style="color:#DF2A3F;">4</font> |  |  | 4 | 4 |  |
| **内存块2** |  | <font style="color:#DF2A3F;">2</font> | 2 | 2 | <font style="color:#DF2A3F;">3</font> | 3 | 3 |  |  | <font style="color:#DF2A3F;">1</font> | 1 |  |
| **内存块3** |  |  | <font style="color:#DF2A3F;">1</font> | 1 | 1 | <font style="color:#DF2A3F;">2</font> | 2 |  |  | 2 | <font style="color:#DF2A3F;">0</font> |  |
| **是否缺页** | 是 | 是 | 是 | 是 | 是 | 是 | 是 |  |  | 是 | 是 |  |


+ 缺页率 = 9 / 12

### 思考：当内存块增加为4，缺页次数是否会下降？
+ 不会。
+ 这种现象称为Belady（贝拉迪）异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
+ 只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

### 最近最久未使用算法LRU
每次淘汰的页面是最近最久未使用的页面

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间。

| 页号 | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址 |
| --- | --- | --- | --- | --- | --- |


当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：

1,8,1,7,8,2,7,2’1,8,3,8,2,1,3,1‘7,1,3,7

| **访问页面** | **1** | **8** | **1** | **7** | **8** | **2** | **7** | **2** | **1** | **8** | **3** | **8** | **2** | **1** | **3** | **1** | **7** | **1** | **3** | **7** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **内存块1** | <font style="color:#DF2A3F;">1</font> | 1 |  | 1 | | 1 | | | | | 1 | | | | | | 1 | | | |
| **内存块2** | | <font style="color:#DF2A3F;">8</font> |  | 8 | | 8 | | | | | 8 | | | | | | <font style="color:#DF2A3F;">7</font> | | | |
| **内存块3** | | | | <font style="color:#DF2A3F;">7</font> | | 7 | | | | | <font style="color:#DF2A3F;">3</font> | | | | | | 3 | | | |
| **内存块4** | | | | | | <font style="color:#DF2A3F;">2</font> | | | | | 2 | | | | | | 2 | | | |
| **是否缺页** | 是 | 是 | | 是 | | 是 | | | | | 是 | | | | | | 是 | | | |


在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。

+ 缺页率 6 / 20

### 评价
该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

### 时钟置换算法CLOCK（待添加）