

# 页面置换算法
**回顾**

+ 请求分页存储管理与基本分页存储管理的主要区别：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
+ **<font style="color:#DF2A3F;">用页面置换算法决定应该换出哪个页面</font>**

页面的换入、换出需要磁盘I/0,会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**

## 最佳置换算法OPT
每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：

7，0，1，2，0，3，0，4‘2，3，0，3，2，1，2，0’1，7，0，1

| **访问页面** | **7** | **0** | **1** | **2** | **0** | **3** | **0** | **4** | **2** | **3** | **0** | **3** | **2** | **1** | **2** | **0** | **1** | **7** | **0** | **1** |
| --- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **内存块1** | <font style="color:#DF2A3F;">7</font> | 7 | 7 | **<font style="color:#2F8EF4;">2（标注1）</font>** |  | 2 | <font style="color:#DF2A3F;"></font> | 2 |  |  | 2 |  |  | 2 |  |  |  | <font style="color:#DF2A3F;">7</font> |  |  |
| **内存块2** |  | <font style="color:#DF2A3F;">0</font> | 0 | 0 |  | 0 |  | <font style="color:#DF2A3F;">4</font> |  |  | <font style="color:#DF2A3F;">0</font> |  |  | 0 |  |  |  | 0 |  |  |
| **内存块3** |  |  | <font style="color:#DF2A3F;">1</font> | 1 | <font style="color:#DF2A3F;"></font> | <font style="color:#DF2A3F;">3</font> |  | 3 |  |  | 3 |  |  | <font style="color:#DF2A3F;">1</font> |  |  |  | 1 |  |  |
| **是否缺页** | 是 | 是 | 是 | 是 |  | 是 |  | 是 |  |  | 是 |  |  | 是 |  |  |  | 是 |  |  |


**<font style="color:#2F8EF4;">2（标注1）：选择从0,1,7中淘汰一页。按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面</font>**

+ 整个过程**缺页中断发生了9**次，**页面置换发生了6**次。

注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。

+ **缺页率 = 9 / 20 = 45%**

### 评价
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。

## 先进先出置换算法FIFO
每次选择淘汰的页面是最早进入内存的页****面

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。

队列的最大长度取决于系统为进程分配了多少个内存块。

例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：

3，2，1，0，3，2，4，3‘2，1，0，4

| **访问页面** | **3** | **2** | **1** | **0** | **3** | **2** | **4** | **3** | **2** | **1** | **0** | **4****** |
| --- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **内存块1** | <font style="color:#DF2A3F;">3</font> | 3 | 3 | <font style="color:#DF2A3F;">0</font> | 0<font style="color:#DF2A3F;"></font> | 0 | <font style="color:#DF2A3F;">4</font> |  |  | 4 | 4 |  |
| **内存块2** |  | <font style="color:#DF2A3F;">2</font> | 2 | 2 | <font style="color:#DF2A3F;">3</font> | 3 | 3 |  |  | <font style="color:#DF2A3F;">1</font> | 1 |  |
| **内存块3** |  |  | <font style="color:#DF2A3F;">1</font> | 1 | 1 | <font style="color:#DF2A3F;">2</font> | 2 |  |  | 2 | <font style="color:#DF2A3F;">0</font> |  |
| **是否缺页** | 是 | 是 | 是 | 是 | 是 | 是 | 是 |  |  | 是 | 是 |  |


+ 缺页率 = 9 / 12

### 思考：当内存块增加为4，缺页次数是否会下降？
+ 不会。
+ 这种现象称为Belady（贝拉迪）异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
+ 只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

## 最近最久未使用算法LRU
每次淘汰的页面是最近最久未使用的页面

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间。

| 页号 | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址 |
| --- | --- | --- | --- | --- | --- |


当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：

1,8,1,7,8,2,7,2’1,8,3,8,2,1,3,1‘7,1,3,7

| **访问页面** | **1** | **8** | **1** | **7** | **8** | **2** | **7** | **2** | **1** | **8** | **3** | **8** | **2** | **1** | **3** | **1** | **7** | **1** | **3** | **7** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **内存块1** | <font style="color:#DF2A3F;">1</font> | 1 |  | 1 | | 1 | | | | | 1 | | | | | | 1 | | | |
| **内存块2** | | <font style="color:#DF2A3F;">8</font> |  | 8 | | 8 | | | | | 8 | | | | | | <font style="color:#DF2A3F;">7</font> | | | |
| **内存块3** | | | | <font style="color:#DF2A3F;">7</font> | | 7 | | | | | <font style="color:#DF2A3F;">3</font> | | | | | | 3 | | | |
| **内存块4** | | | | | | <font style="color:#DF2A3F;">2</font> | | | | | 2 | | | | | | 2 | | | |
| **是否缺页** | 是 | 是 | | 是 | | 是 | | | | | 是 | | | | | | 是 | | | |


在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。

+ 缺页率 6 / 20

### 评价
该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

## 时钟置换算法CLOCK（待添加）
# 内存管理

传统的内存管理使得CPU能够直接访问物理内存，例如我们在dosbox中
![[20251105-17-31-34.png]]



## 内存空间的分配与回收
### 连续分配方式（待添加）
### 非连续分配方式
#### 产生原因
考虑支持多道程序的两种连续分配方式：

+ 1.固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。
+ 2.动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高

如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”

#### 与连续分配方式的区别
连续分配   ：为用户进程分配的必须是一个连续的内存空间。

非连续分配：为用户进程分配的可以是一些分散的内存空间。

#### 基本分页存储管理
![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/33704534/1676711984099-3834d7ac-c30f-4846-bf10-6d4c4ad42827.jpeg)

:::info
假设进程A大小为23MB,但是每个分区大小只有10MB,如果进程只能占用一个分区，那显然放不下。

**解决思路：**如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）进程A的最后一个部分是3MB,放入分区后会产生7MB的内部碎片。

:::

固定分区分配中内存碎片一般会比较大，但如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。

基本分页存储管理的思想一一把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

+ 将**<font style="color:#DF2A3F;">内存空间</font>**分为一个个大小相等的分区（比如：每个分区4KB),每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个贡框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。
+ 将**<font style="color:#DF2A3F;">用户进程的地址空间</font>**也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”页号也是从0开始。(注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片)

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/33704534/1676712572117-f5fb673f-50c1-499f-b26f-45fec25accb0.jpeg)

##### 如何实现地址转换？
![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/33704534/1676714692043-bdbbd0ce-5600-4316-9a8b-f662f4fe9217.jpeg)

:::info
1.要算出逻辑地址对应的页号

页号=逻辑地址/页面长度（取除法的整数部分）

80 / 50 = **1号页面**

2.要知道该页号对应页面在内存中的起始地址

页面在内存中的起始位置：操作系统需要用某种数据结构记录进程各个页

面的起始位置。

**1号页在内存中存放的起始位置450**

3.要算出逻辑地址在页面内的“偏移量”

页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）

80 % 50 = **30偏移量**

4.物理地址=页面始址+页内偏移量



为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂



假设用32个二进制位表示逻辑地址，页面大小为2^12B=4096B=4KB

0号页的逻辑地址空间应该是0~4095，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">00</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">00</font>****<u>1111,1111,1111</u>**

1号页的逻辑地址空间应该是4096~8191，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">01</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">01</font>****<u>1111,1111,1111</u>**

2号页的逻辑地址空间应该是8192~12287，用二进制表示应该是：

000000000000000000**<font style="color:#DF2A3F;">10</font>****<u>0000,0000,0000</u>**~000000000000000000**<font style="color:#DF2A3F;">10</font>****<u>1111,1111,1111</u>**

**<u></u>**

结论：如果每个页面大小为2B,用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号

:::

##### 逻辑结构地址
以页面大小为2^12B为例

| **31            ......................                    12** | **11            ....              0** |
| --- | --- |
| **页号P** | **页内偏移量W** |


:::info
Eg:逻辑地址2，用二进制表示应该是000000000000000000**<font style="color:#DF2A3F;">00</font>**,0000,0000,0010

可知页号为0

若0号页在内存中的起始地址为X,则逻辑地址2对应的物理地址应该是X+000000000010



Eg:逻辑地址4097，用二进制表示应该是000000000000000000**<font style="color:#DF2A3F;">01</font>**,0000,0000,0001

可知页号为1

若1号页在内存中的起始地址为X,则逻辑地址4097对应的物理地址应该是X+000000000001

:::

##### 页表
为了得知每个页面在内存中的起始地址。

+ 1.一个进程对应一张页表
+ 2.进程的每一页对应一个页表项
+ 3.每个**<font style="color:#DF2A3F;">页表项</font>**由“页号”和“块号”组成
+ 4.页表记录进程页面和实际存放的内存块之间的对应关系
+ 5.M号内存块的起始地址就是M*内存块大小

![画板](https://cdn.nlark.com/yuque/0/2023/jpeg/33704534/1676722021838-bf937b70-dcae-499e-9d34-65f6904361b5.jpeg)

##### 为什么每个页表项的长度是相同的，页号是“隐含”的？
Eg：假设某系统物理内存大小为4GB,页面大小为4KB,则每个页表项至少应该为多少字节？

+ 4GB=2^32B	4KB=2^12B
+ 因此4GB的内存总共会被分为2^32/2^12=2^20个内存块，因此内存块号的范围应该是0~2^20-1
+ 因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够

各页表项会按顺序连续地存放在内存中，如果该页表在内存中存放的起始地址为X，则M号页对应的页表项一定是存放在内存地址为X+3*M，然后在该地址找块号是多少。

在本例中，一个页表项占3B,如果进程由n个页面，则该进程的页表总共会占3*n个字节



